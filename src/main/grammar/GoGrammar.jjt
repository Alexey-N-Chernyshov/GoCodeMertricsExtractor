/**
 * @author Alexey Chernyshov
 */

options
{
  STATIC = false;
  IGNORE_CASE = false;
  MULTI = true;        // in multi mode the type of the node is derived from the name of the node
  VISITOR = true;
}

PARSER_BEGIN(GoParser)

package com.github.alexey_n_chernyshov;

/**
 * Parses go lang source and produces AST.
 * Go lang source should be preprocessed before parsing to be ensure that
 * all necessary semicolons (;) are inserted.
 */
public class GoParser
{
}

PARSER_END(GoParser)

SKIP:
{
/* Whitespace */
  "\t"
| "\n"
| "\r"
| " "
/* comments */
| < "//" (~["\r", "\n"])* >
| < "/*" > : ML_COMMENT_STATE
}

<ML_COMMENT_STATE> SKIP :
{
  < "*/" > : DEFAULT
| < ~[] >
}

/* tokens are */
TOKEN:
{
/* keywords */
  <TOKEN_BREAK: "break">
| <TOKEN_DEFAULT: "default">
| <TOKEN_FUNC: "func">
| <TOKEN_INTERFACE: "interface">
| <TOKEN_SELECT: "select">
| <TOKEN_CASE: "case">
| <TOKEN_DEFER: "defer">
| <TOKEN_GO: "go">
| <TOKEN_MAP: "map">
| <TOKEN_STRUCT: "struct">
| <TOKEN_CHAN: "chan">
| <TOKEN_ELSE: "else">
| <TOKEN_GOTO: "goto">
| <TOKEN_PACKAGE: "package">
| <TOKEN_SWITCH: "switch">
| <TOKEN_CONST: "const">
| <TOKEN_FALLTROUGH: "fallthrough">
| <TOKEN_IF: "if">
| <TOKEN_RANGE: "range">
| <TOKEN_TYPE: "type">
| <TOKEN_CONTINUE: "continue">
| <TOKEN_FOR: "for">
| <TOKEN_IMPORT: "import">
| <TOKEN_RETURN: "return">
| <TOKEN_VAR: "var">

/* operators and delimiters */
| <TOKEN_PLUS: "+">
| <TOKEN_AND: "&">
| <TOKEN_PLUSEQUAL: "+=">
| <TOKEN_ANDEQUAL: "&=">
| <TOKEN_ANDAND: "&&">
| <TOKEN_EQUALEQUAL: "==">
| <TOKEN_NOTEQUAL: "!=">
| <TOKEN_LPAREN: "(">
| <TOKEN_RPAREN: ")">
| <TOKEN_MINUS: "-">
| <TOKEN_OR: "|">
| <TOKEN_MINUSEQUAL: "-=">
| <TOKEN_OREQUAL: "|=">
| <TOKEN_OROR: "||">
| <TOKEN_LESS: "<">
| <TOKEN_LESSOREQUAL: "<=">
| <TOKEN_LSQUAREPAREN: "[">
| <TOKEN_RSQUAREPAREN: "]">
| <TOKEN_MULT: "*">
| <TOKEN_XOR: "^">
| <TOKEN_MULEQUAL: "*=">
| <TOKEN_XOREQUAL: "^=">
| <TOKEN_LESSMINUS: "<-">
| <TOKEN_GREATER: ">">
| <TOKEN_GREATEREQUAL: ">=">
| <TOKEN_LCURLYBRACE: "{">
| <TOKEN_RCURLYBRACE: "}">
| <TOKEN_DIV: "/">
| <TOKEN_LESSLESS: "<<">
| <TOKEN_DIVEQUAL: "/=">
| <TOKEN_LESSLESSEQUAL: "<<=">
| <TOKEN_PLUSPLUS: "++">
| <TOKEN_EQUAL: "=">
| <TOKEN_COLONEQUAL: ":=">
| <TOKEN_COMMA: ",">
| <TOKEN_SEMICOLON: ";">
| <TOKEN_PERCENT: "%">
| <TOKEN_GREATERGREATER: ">>">
| <TOKEN_PERCENTEQUAL: "%=">
| <TOKEN_GREATERGREATEREQUAL: ">>=">
| <TOKEN_MINNUSMINUS: "--">
| <TOKEN_EXCLAMATION: "!">
| <TOKEN_ELLIPSIS: "...">
| <TOKEN_DOT: ".">
| <TOKEN_COLON: ":">
| <TOKEN_ANDXOR: "&^">
| <TOKEN_ANDXOREQUAL: "&^=">

/* Literals */
| <TOKEN_DECIMAL_INTEGER_LITERAL: ("0")|(["1"-"9"](["0"-"9"])*)>

| <TOKEN_OCTAL_INTEGER_LITERAL: "0"(["0"-"7"])+>

| <TOKEN_HEX_INTEGER_LITERAL: ("0x"|"0X")(["0"-"9", "a"-"f", "A"-"F"])+>

| <TOKEN_FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<DECIMAL_EXPONENT>)?
                                  | (["0"-"9"])+ <DECIMAL_EXPONENT>
                                  | "." (["0"-"9"])+ (<DECIMAL_EXPONENT>)? >
    | <#DECIMAL_EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+>

| <TOKEN_IMAGINARY_LITERAL: ((<TOKEN_FLOATING_POINT_LITERAL>)|(["0"-"9"])*)"i">

| <TOKEN_RUNE_LITERAL: "'" ( (<UNICODE_VALUE>) | (<BYTE_VALUE>) ) "'">
    | <#UNICODE_VALUE: ( ~["\n"]) | (<LITTLE_U_VALUE>) | (<BIG_U_VALUE>) | (<ESCAPED_CHAR>)>
    | <#BYTE_VALUE: (<OCTAL_BYTE_VALUE>) | (<HEX_BYTE_VALUE>)>
    | <#OCTAL_BYTE_VALUE: "\\" (["0"-"7"]) (["0"-"7"]) (["0"-"7"])>
    | <#HEX_BYTE_VALUE: "\\x" (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])>
    | <#LITTLE_U_VALUE: "\\u" (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])
                              (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])>
    | <#BIG_U_VALUE:  "\\U" (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])
                            (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])
                            (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])
                            (["0"-"9", "a"-"f", "A"-"F"]) (["0"-"9", "a"-"f", "A"-"F"])>
    | <#ESCAPED_CHAR: "\\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"" )>

| <TOKEN_STRING_LITERAL: (<RAW_STRING_LITERAL>) | (<INTERPRETED_STRING_LITERAL>)>
    | <#RAW_STRING_LITERAL: "`" (~[])* "`">
    | <#INTERPRETED_STRING_LITERAL: "\"" ((<UNICODE_VALUE>) | (<BYTE_VALUE>))* "\"">

| <TOKEN_IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}


void IntegerLiteral() : { Token t; }
{
  t = <TOKEN_DECIMAL_INTEGER_LITERAL> { jjtThis.value = t.image; }
| t = <TOKEN_OCTAL_INTEGER_LITERAL> { jjtThis.value = t.image; }
| t = <TOKEN_HEX_INTEGER_LITERAL> { jjtThis.value = t.image; }
}

void FloatLiteral() : { Token t; }
{
  t = <TOKEN_FLOATING_POINT_LITERAL> { jjtThis.value = t.image; }
}

void ImaginaryLiteral() : { Token t; }
{
  t = <TOKEN_IMAGINARY_LITERAL> { jjtThis.value = t.image; }
}

void RuneLiteral() : { Token t; }
{
  t = <TOKEN_RUNE_LITERAL> { jjtThis.value = t.image; }
}

void StringLiteral() : { Token t; }
{
  t = <TOKEN_STRING_LITERAL> { jjtThis.value = t.image; }
}

void Literal() #void : {}
{
  LOOKAHEAD(2)
  /* Base literals */
  IntegerLiteral()
| FloatLiteral()
| ImaginaryLiteral()
| RuneLiteral()
| StringLiteral()

| FunctionLit()
}

void FunctionLit() : {}
{
    <TOKEN_FUNC> Function()
}

void Function() #void : {}
{
  Signature() FunctionBody()
}

void Signature() #void : {}
{
  Parameters() ( Result() )?
}

void Result() : {}
{
  LOOKAHEAD(3)
  Parameters()
| Type()
}

void Parameters() : {}
{
  <TOKEN_LPAREN> (ParameterList() (<TOKEN_COMMA>)? )? <TOKEN_RPAREN>
}

void ParameterList() #void : {}
{
  ParameterDecl() (LOOKAHEAD(2) <TOKEN_COMMA> ParameterDecl() )*
}

void ParameterDecl() #void : {}
{
  LOOKAHEAD(2)
  IdentifierList() ( <TOKEN_ELLIPSIS> )? Type()
| Type()
}

void IdentifierList() #void : {}
{
  Identifier() (<TOKEN_COMMA> Identifier() )*
}

void FunctionBody() : {}
{
  Block()
}

void TypeName() #void : {}
{
  LOOKAHEAD(2)
  QualifiedIdentifier()
| Identifier()
}

//TODO
void TypeLit() #void : {}
{
  LOOKAHEAD(2)
  ArrayType()
| StructType()
| InterfaceType()
| PointerType()
| SliceType()
}

void ArrayType() : {}
{
  <TOKEN_LSQUAREPAREN> Expression() <TOKEN_RSQUAREPAREN> Type()
}

void StructType() : {}
{
  <TOKEN_STRUCT> <TOKEN_LCURLYBRACE> (FieldDecl() <TOKEN_SEMICOLON>)* <TOKEN_RCURLYBRACE>
}

void SliceType() : {}
{
  <TOKEN_LSQUAREPAREN> <TOKEN_RSQUAREPAREN> Type()
}

void FieldDecl() : {}
{
   (LOOKAHEAD(2) IdentifierList() Type() | (<TOKEN_MULT>)? TypeName()) (StringLiteral())?
}

void InterfaceType() : {}
{
  <TOKEN_INTERFACE> <TOKEN_LCURLYBRACE> ( MethodSpec() <TOKEN_SEMICOLON> )* <TOKEN_RCURLYBRACE>
}

void PointerType() : {}
{
  <TOKEN_MULT> Type()
}

void MethodSpec() : {}
{
  LOOKAHEAD(2)
  MethodName() Signature()
| InterfaceTypeName()
}

void MethodName() : {}
{
  Identifier()
}

void InterfaceTypeName() : {}
{
  TypeName()
}

void Type() : {}
{
  TypeName()
| TypeLit()
| <TOKEN_LPAREN> Type() <TOKEN_RPAREN>
}

void Block() : {}
{
  <TOKEN_LCURLYBRACE> StatementList() <TOKEN_RCURLYBRACE>
}

void StatementList() : {}
{
  (Statement() <TOKEN_SEMICOLON> )*
}

//TODO
void Statement() : {}
{
  Declaration()
| SimpleStatement()
| Block()
}

//TODO
void SimpleStatement() : {}
{
  LOOKAHEAD(3)
  ShortVarDeclaration()
//| Assignment()
| Expression()
}

void Assignment() : {}
{
  ExpressionList() (<TOKEN_PLUSEQUAL> | <TOKEN_MINUSEQUAL> | <TOKEN_EQUAL> ) ExpressionList()
}

void ShortVarDeclaration() : {}
{
  IdentifierList() <TOKEN_COLONEQUAL> ExpressionList()
}

SimpleNode SourceFile() : {}
{
  PackageClause() <TOKEN_SEMICOLON>
  ( ImportDecl() <TOKEN_SEMICOLON> )*
  ( TopLevelDecl() <TOKEN_SEMICOLON> )*
  <EOF> { return jjtThis; }
}

void PackageClause() : {}
{
  <TOKEN_PACKAGE> Identifier()
}

void ImportDecl() : {}
{
  <TOKEN_IMPORT> ( ImportSpec() | <TOKEN_LPAREN> ( ImportSpec() <TOKEN_SEMICOLON> )* <TOKEN_RPAREN> )
}

void ImportSpec() #void : {}
{
  ( <TOKEN_DOT> | PackageName() )? ImportPath()
}

void ImportPath() : {}
{
  StringLiteral()
}

void TopLevelDecl() : {}
{
  Declaration()
| <TOKEN_FUNC> (FunctionDecl() | MethodDecl())
}

void MethodDecl(): {}
{
  Reciever() MethodName() (LOOKAHEAD(3) Function() | Signature())
}

void Reciever() : {}
{
  Parameters()
}

// TODO
void Declaration() : {}
{
  ConstDecl()
|  TypeDecl()
|  VarDecl()
}

void ConstDecl() : {}
{
  <TOKEN_CONST> ( ConstSpec() | <TOKEN_LPAREN> (ConstSpec() <TOKEN_SEMICOLON>)* <TOKEN_RPAREN>)
}

void TypeDecl() : {}
{
  <TOKEN_TYPE> (TypeSpec() | <TOKEN_LPAREN> (TypeSpec() <TOKEN_SEMICOLON> )* <TOKEN_RPAREN> )
}

void TypeSpec() : {}
{
  Identifier() Type()
}

void ConstSpec() : {}
{
  IdentifierList() ( (Type())? <TOKEN_EQUAL> ExpressionList() )?
}

void VarDecl() : {}
{
  <TOKEN_VAR> (VarSpec() | <TOKEN_LPAREN> (VarSpec())* <TOKEN_RPAREN>)
}

void VarSpec() : {}
{
  IdentifierList() (<TOKEN_EQUAL> ExpressionList() | Type() ( <TOKEN_EQUAL> ExpressionList() )?)
}

void FunctionDecl() : {}
{
  FunctionName() (LOOKAHEAD(3) Function() | Signature())
}

void FunctionName() : {}
{
  Identifier()
}

void Identifier() : { Token t; }
{
  t = <TOKEN_IDENTIFIER> { jjtThis.value = t.image; }
}

void PackageName() : { Token t; }
{
  t = <TOKEN_IDENTIFIER> { jjtThis.value = t.image; }
}

void QualifiedIdentifier() #void : {}
{
  PackageName() <TOKEN_DOT> Identifier()
}

void OperandName() #void : {}
{
  LOOKAHEAD(2)
  QualifiedIdentifier()
| Identifier()
}

//TODO
void ReceiverType() : {}
{
  TypeName()
//  | <TOKEN_LPAREN> ReceiverType() <TOKEN_RPAREN>
//  | <TOKEN_LPAREN> <TOKEN_MULT> TypeName() <TOKEN_RPAREN>
}

void MethodExpression() : {}
{
  ReceiverType() <TOKEN_DOT> MethodName()
}

//TODO
void Operand() : {}
{
  LOOKAHEAD(3)
//  MethodExpression()
 <TOKEN_LPAREN> Expression() <TOKEN_RPAREN>
| OperandName()
| Literal()
}

// TODO
void PrimaryExpression() : {}
{
  LOOKAHEAD(3)
  Operand() PrimaryExpressionLR()
| Operand()
}

//to avoid Left Recursion
void PrimaryExpressionLR() #void : {}
{
  LOOKAHEAD(3)
  Arguments()
| PrimaryExpression() PrimaryExpressionLR()
}

void Arguments() : {}
{
  <TOKEN_LPAREN>
  (
  (LOOKAHEAD(3) ExpressionList() | Type() (LOOKAHEAD(2) <TOKEN_COMMA> ExpressionList())? )
  (<TOKEN_ELLIPSIS>)? (<TOKEN_COMMA>)?
  )?
  <TOKEN_RPAREN>
}

void ExpressionList() : {}
{
  Expression() (LOOKAHEAD(2) <TOKEN_COMMA> Expression() )*
}

void UnaryExpression() #void : { Token t; }
{
  PrimaryExpression()
| t = <TOKEN_PLUS> UnaryExpression() { jjtThis.value = t.image; } #UnaryPlus(1)
| t = <TOKEN_MINUS> UnaryExpression() { jjtThis.value = t.image; } #UnaryMinus(1)
| t = <TOKEN_EXCLAMATION> UnaryExpression() { jjtThis.value = t.image; } #UnaryNot(1)
| t = <TOKEN_XOR> UnaryExpression() { jjtThis.value = t.image; } #UnaryXor(1)
| t = <TOKEN_MULT> UnaryExpression() { jjtThis.value = t.image; } #UnaryMult(1)
| t = <TOKEN_AND> UnaryExpression() { jjtThis.value = t.image; } #UnaryAnd(1)
| t = <TOKEN_LESSMINUS> UnaryExpression() { jjtThis.value = t.image; } #UnaryLessMinus(1)
}

void MultOperators() #void : { Token t; }
{
  UnaryExpression() (
    LOOKAHEAD(2) (
    (t = <TOKEN_MULT> UnaryExpression() { jjtThis.value = t.image; }           #Mult(2) )
  | (t = <TOKEN_DIV> UnaryExpression() { jjtThis.value = t.image; }            #Div(2)  )
  | (t = <TOKEN_PERCENT> UnaryExpression() { jjtThis.value = t.image; }        #DivInt(2) )
  | (t = <TOKEN_LESSLESS> UnaryExpression() { jjtThis.value = t.image; }       #ShiftLeft(2) )
  | (t = <TOKEN_GREATERGREATER> UnaryExpression() { jjtThis.value = t.image; } #ShiftRight(2) )
  | (t = <TOKEN_AND> UnaryExpression() { jjtThis.value = t.image; }            #And(2) )
  | (t = <TOKEN_ANDXOR> UnaryExpression() { jjtThis.value = t.image; }         #AndXor(2) )
    )
  )*
}

void AddOperators() #void : { Token t; }
{
  MultOperators() (
    LOOKAHEAD(2) (
    (t = <TOKEN_PLUS> MultOperators() { jjtThis.value = t.image; }  #Add(2) )
  | (t = <TOKEN_MINUS> MultOperators() { jjtThis.value = t.image; } #Sub(2) )
  | (t = <TOKEN_OR> MultOperators() { jjtThis.value = t.image; }    #Or(2)  )
  | (t = <TOKEN_XOR> MultOperators() { jjtThis.value = t.image; }   #Xor(2) )
    )
  )*
}

void RelOperators() #void : { Token t; }
{
  AddOperators() (
    (t = <TOKEN_EQUALEQUAL> AddOperators() { jjtThis.value = t.image; }   #Equal(2) )
  | (t = <TOKEN_NOTEQUAL> AddOperators() { jjtThis.value = t.image; }     #NotEqual(2) )
  | (t = <TOKEN_LESS> AddOperators() { jjtThis.value = t.image; }         #Less(2) )
  | (t = <TOKEN_LESSOREQUAL> AddOperators() { jjtThis.value = t.image; }  #LessEqual(2) )
  | (t = <TOKEN_GREATER> AddOperators() { jjtThis.value = t.image; }      #Greater(2) )
  | (t = <TOKEN_GREATEREQUAL> AddOperators() { jjtThis.value = t.image; } #GreaterEqual(2) )
  )*
}

void AndAndOperator() #void : { Token t; }
{
  RelOperators() (
    (t = <TOKEN_ANDAND> RelOperators() { jjtThis.value = t.image; } #AndAnd(2) )
  )*
}

void OrOrOperator() #void : { Token t; }
{
  AndAndOperator() (
    (t = <TOKEN_OROR> AndAndOperator() { jjtThis.value = t.image; } #OrOr(2) )
  )*
}

void Expression() #void : {}
{
  OrOrOperator()
}